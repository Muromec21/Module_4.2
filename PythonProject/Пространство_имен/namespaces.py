import math

def print(*args):
    return 'Ok'

def square(x):
    global a
    a = x ** 2
    print(globals())
    print(locals())
    return a
a = 5
b = square(2)
print(a)
print(b)
print(globals())

#Лекция. Пространство имен
# ⠀
# Пространство имён
#
# В рамках данного занятия рассматривается понятие пространства имён,
# его основные характеристики и типы.
# Анализируются принципы работы с пространствами имён,
# их назначение и способы организации.
#
# Для наглядности упоминается файл с именем «namespaces»
# (пространство имен), который иллюстрирует соответствующую концепцию.
#
# Допустим, существует переменная «a», значение которой равно 5.
# Эта переменная доступна для выполнения различных операций в пределах
# определённой области видимости. Её текущее значение можно просмотреть (Рис.2),
# обеспечивая возможность дальнейших вычислений и обращения к ней.
#
# Переменная «a» располагается в глобальном
# пространстве имён модуля «namespaces».
#
# Следует отметить, что язык программирования Python широко применяет
# концепцию пространства имён, создавая его практически для каждого
# объекта.
#
# Для иллюстрации этого принципа можно выполнить импорт
# «Дзена Python» — набора философских принципов, лежащих в основе
# разработки на Python (Рис.3).
#
# Особое внимание следует обратить на заключительный пункт упомянутых
# принципов. В нём выражается идея, которая в свободном переводе звучит
# примерно так: «Пространство имён — это отличная концепция.
# Давайте использовать её активнее» (Рис.4).
# Этот подход подчёркивает важность структурирования кода с помощью
# пространств имён для улучшения читаемости и управляемости программ.
#
# Язык программирования Python активно использует концепцию пространства
# имён, что становится особенно очевидным при работе с классами в будущем.
# В текущем примере рассматривается глобальное пространство имён файла
# «namespaces», в котором могут находиться переменные,
# функции и имена модулей.
#
# Для демонстрации этого принципа можно импортировать модуль «math»,
# аналогично предыдущим примерам (Рис.5).
# После выполнения импорта модуль становится доступным,
# и его атрибуты можно использовать, применяя нотацию через точку.
# Такой подход схож с импортом модулей из пакетов,
# где указывается путь к нужному файлу.
# Это подчёркивает гибкость работы с пространствами имён в Python.
#
# В качестве примера рассмотрим модуль «math».
# Используя его, можно вычислить квадратный корень переменной «a».
# Выполнение соответствующего выражения возвращает значение,
# равное 2,23 (Рис.6).
#
# Этот процесс включает обращение к модулю «math»,
# вызов его атрибута — функции «sqrt», и передачу ей переменной
# из глобального пространства имён.
# Такой подход демонстрирует взаимодействие между разными уровнями
# пространств имён в Python.
#
# В результате выполнения импорта модуля «math» в глобальном пространстве
# имён «namespaces» появилось новое имя — «math». Чтобы убедиться в этом,
# можно использовать функцию «globals»,
# которая возвращает словарь всех доступных элементов
# глобального пространства имён.
#
# Этот словарь содержит пары ключ-значение,
# где ключи представляют имена объектов,
# а значения — соответствующие объекты (Рис.7, 8).
# Таким образом, импортированный модуль становится доступным
# для дальнейшего использования.
#
# В полученном словаре глобального пространства имён действительно
# присутствует ключ «math» (Рис.9). Это имя используется для обращения
# к соответствующему модулю, позволяя вызывать его функции и атрибуты.
#
# Значением имени «math» в глобальном пространстве имён
# является объект типа «module math» (Рис.10).
# Это указывает на то, что модуль был успешно импортирован и привязан
# к указанному имени. Теперь к его функциям и атрибутам можно обращаться
# с использованием этой ссылки.
#
# В глобальном пространстве имён также присутствует имя «a»,
# связанное с объектом типа «int» со значением 5 (Рис.11).
# Это означает, что переменная «a» была создана и хранит целое число,
# к которому можно обращаться по указанному имени в
# текущем пространстве имён.
#
# При использовании конструкции "from math import *"
# все публичные атрибуты модуля «math» добавляются
# в глобальное пространство имён текущего файла «namespaces».
# Это можно проверить, вызвав функцию globals,
# которая покажет значительное увеличение числа
# доступных объектов (Рис.12, 13, 14).
#
#
#
# Таким образом, происходит импорт всех имён из
# пространства имён модуля «math» в глобальное пространство текущего
# модуля. Это увеличивает количество доступных атрибутов,
# но может привести к конфликтам имён, если импортированные элементы
# совпадают с уже существующими. Поэтому такой подход следует
# применять с осторожностью.
#
# Действительно, наличие локальных пространств имён открывает
# дополнительные возможности управления переменными.
# Чтобы проиллюстрировать это, вернём импорт модуля с использованием
# команды "import math", чтобы избежать перенасыщения глобального
# пространства имён.
#
# Создадим функцию, вычисляющую квадрат переданного значения.
# Внутри этой функции определим локальную переменную «a»,
# присвоив ей результат операции возведения в квадрат аргумента «x»
# с использованием выражения "a = x ** 2".
# Затем функция будет возвращать значение этой переменной «a» (Рис.15).
#
# После выполнения кода в глобальном пространстве имён остаётся
# переменная «a» со значением 5, а также появляется
# новое имя — функция «square» (Рис.16, 17). Это связано с тем,
# что внутри функции «square» создаётся локальная переменная «a»,
# которая существует только в её собственном пространстве имён.
#
# Внутри функции «square» создаётся локальное пространство имён,
# в котором определяется переменная «a», равная квадрату переданного
# аргумента. При вызове square(2) аргумент x принимает значение 2.
# Переменная a внутри функции получает значение 2 ** 2, то есть 4.
#
#
#
# Затем создаётся глобальная переменная «b», которой присваивается
# результат вызова функции square(2). После этого её значение выводится
# на экран, и отображается число 4,
# поскольку это квадрат числа 2, (Рис.18).
#
# Если внутри функции «square» вызвать функцию globals(),
# она вернёт словарь глобального пространства имён (Рис.19).
# Однако локальные переменные функции, такие как «a», в этот словарь
# не попадут, поскольку globals() отображает только глобальные объекты.
#
# Если прокрутить вывод до конца, можно заметить,
# что переменная «a» берётся из глобального пространства имён (Рис.20).
# Это происходит из-за того, что функция globals() всегда возвращает
# глобальное пространство имён, независимо от того, где она вызвана.
#
# Несмотря на то, что функция «square» имеет своё локальное пространство
# имён, доступ к глобальным переменным остаётся возможным,
# если они не переопределены внутри функции. Если бы внутри функции
# «square» не было объявления переменной «a», а был бы просто доступ
# к «a», Python искал бы её в глобальном пространстве имён,
# следуя принципу области видимости
# (LEGB — Local, Enclosing, Global, Built-in).
#
# При вызове функции locals() внутри функции «square» выводится словарь
# локального пространства имён (Рис.21).
#
# Изображениеundefined
# Рис.21
#
#
#
# При выполнении программы переменная "a", объявленная в глобальном
# пространстве имён, сохраняет значение 5. Однако при вызове функции
# square(2) внутри неё создаётся новая переменная "a",
# хранящая локальное значение 4 (результат вычисления 2 ** 2).
#
# Это демонстрирует принцип работы локального пространства имён:
# функции создают собственные области видимости,
# независимые от глобального пространства имён.
# Когда в функции происходит присваивание "a = x ** 2",
# создаётся новое имя "a", доступное только внутри функции.
# Глобальная переменная "a" остаётся неизменной.
#
# Если бы внутри функции не было присваивания "a = x ** 2",
# Python искал бы "a" в глобальном пространстве,
# но поскольку локальная переменная определена,
# она перекрывает глобальную. Таким образом,
# изменение локальной "a" никак не влияет на глобальную переменную
# с тем же именем (Рис.22).
#
# При повторном выводе переменной "a" после вызова функции значение
# остаётся равным 5 (Рис.23). Это происходит потому,
# что функция "square" работает в своём локальном пространстве имён,
# а глобальная переменная "a" остаётся неизменной.
#
# Такое поведение объясняется принципом работы пространств имён в Python.
# Когда мы создаём переменную a в глобальном пространстве и присваиваем
# ей значение 5, она остаётся неизменной до тех пор,
# пока не произойдёт явного изменения в этом пространстве.
#
# При вызове функции "square(2)" внутри неё создаётся локальная
# переменная "a", равная 4 (результат 2 ** 2).
# Однако это локальное значение недоступно за пределами функции.
# Переменная "b" в глобальном пространстве получает результат
# вызова функции, равный 4, но глобальная "a" остаётся равной 5,
# поскольку её значение не изменялось.
#
# Первый вызов "print(a)" выводит значение глобальной переменной "a",
# равное 5. Второй вызов "print(b)" показывает результат функции
# "square(2)", равный 4 (Рис.24).
#
# Даже после вызова функции переменная "a" в глобальном пространстве имён
# осталась неизменной, поскольку внутри функции "square" создавалась
# своя локальная переменная "a". Это возможно благодаря системе
# пространств имён, которая работает как словарь,
# где каждое имя уникально и ссылается на определённый объект
# в своём пространстве.
#
# Однако конфликты имён всё же могут возникать,
# особенно при дублировании имён в разных областях видимости.
# В данном случае локальная "a" перекрыла глобальную только в
# пределах функции, но глобальная переменная осталась нетронутой.
#
# Если необходимо, чтобы функция изменяла значение переменной "a"
# в глобальном пространстве имён, нужно использовать ключевое слово
# "global". Внутри функции square это делается следующим образом:
#
# def square(x):
# global a
# a = x ** 2
#
# Теперь при вызове "square(2)" переменная "a" из глобального
# пространства имён будет перезаписана значением 4,
# поскольку использование оператора "global" позволяет изменять
# глобальные переменные изнутри функции (Рис.25).
#
# В результате выполнения данной команды видим, что переменная "a"
# изменилась, потому что функцию мы вызвали после объявления
# переменной "a" (Рис.26).
#
# В Python существует три основных пространства имён: глобальное,
# локальное и встроенное.
#
# 1) Глобальное пространство имён содержит имена,
# определённые на уровне модуля. Переменная "a", равная 5,
# находилась именно в этом пространстве до вызова функции.
#
# 2) Локальное пространство имён создаётся при вызове функции.
# Переменные, объявленные внутри функции,
# существуют только в её области видимости.
#
# 3) Встроенное пространство имён включает стандартные функции
# и объекты Python, такие как "prin"t, "len", "sum" и т.д.
#
# Порядок поиска имён (LEGB):
#
# L — Local (Локальное)
# E — Enclosing (Закрывающее, для вложенных функций)
# G — Global (Глобальное)
# B — Built-in (Встроенное)
#
# Если внутри функции написать "a ** 2",
# Python сначала будет искать переменную "a" в локальном пространстве.
# Если её там нет, он проверит глобальное пространство,
# а затем встроенные имена.
# Поскольку глобальная переменная "a" была доступна,
# операция возведения в квадрат сработала успешно,
# даже без её объявления в локальном пространстве (Рис.27).
#
# Когда в функции создаётся переменная "d" с присвоением значения
# "x ** 2", это имя регистрируется в локальном пространстве имён функции.
# Переменная "d" существует только во время выполнения функции
# и недоступна за её пределами.
#
# Чтобы использовать это значение в глобальном пространстве,
# необходимо применить оператор "return" (Рис.28). Например:
#
# def square(x):
# d = x ** 2
# return d
#
# Если попытаться вывести значение переменной "d" за пределами функции,
# произойдёт ошибка "NameError", поскольку переменная "d" создаётся
# только в локальном пространстве имён функции и не существует в
# глобальной области видимости (Рис.29).
#
# Переопределение встроенных функций, таких как "print",
# возможно в Python благодаря системе пространств имён (Рис.30).
# Если написать:
#
# def print(*args):
# return "Ok"
#
# Это создаёт локальное пространство имён,
# в котором функция "print" будет ссылаться на пользовательскую версию,
# а не на встроенную функцию "print".
# Теперь каждый вызов "print()" в текущем глобальном пространстве
# вернёт строку "Ok".
#
# При запуске программы стандартная функция "print" перестаёт выполнять
# свою привычную задачу вывода на экран,
# так как её поведение было переопределено (Рис.31).
# Теперь "print" ссылается на пользовательскую функцию,
# которая возвращает строку "Ok" вместо вывода переданных аргументов.
#
# Почему это произошло?
#
# В глобальном пространстве имён появилось
# новое определение функции print.
#
# При вызове "print(...)" Python находит её в глобальном пространстве
# раньше, чем обращается к встроенному пространству.
#
# В результате вместо стандартного вывода на экран происходит
# возврат строки "Ok".
#
# В Python поиск имён осуществляется в определённой последовательности,
# которая называется "изнутри наружу", или правилом LEGB.
# Эта последовательность означает,
# что интерпретатор сначала проверяет локальное пространство имён,
# затем идёт к внешнему, глобальному и встроенному уровням.
#
# Порядок поиска:
#
# 1) Локальное пространство (Local) — внутри текущей функции.
#
# 2) Закрывающее пространство (Enclosing) — пространство внешней функции,
# если есть вложенные функции.
#
# 3) Глобальное пространство (Global) — на уровне модуля.
#
# 4) Встроенное пространство (Built-in) — функции Python по умолчанию,
# такие как "print", "len" и т.д.
#
# Иллюстрация:
#
# a = 10 # Глобальная переменная
# def outer():
# a = 5 # Переменная внешней функции
#
# def inner():
# print(a) # Поиск начинается с локального пространства
# inner()
# outer() # Вывод: 5
#
# Объяснение:
#
# Переменная "a" сначала ищется внутри функции "inner()".
#
# Так как её там нет, интерпретатор проверяет функцию "outer()",
# где "a" = 5.
#
# Глобальная "a" = 10 используется только в том случае,
# если переменная не найдена ни в одном из внутренних пространств.
#
# Если "a" не была бы найдена ни в одном из предыдущих уровней,
# Python искал бы её среди встроенных объектов.
#
# Этот механизм помогает избежать конфликтов имён,
# обеспечивая строгую иерархию поиска.
# Если функция находит переменную на одном уровне,
# она останавливает дальнейший поиск,
# гарантируя предсказуемое поведение программы.